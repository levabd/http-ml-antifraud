## Общее описание

Модуль Headers это часть системы антинакрутки MGID. Каждый браузер формирует специфическую структуру заголовков, отличающуюся от других браузеров/версий/платформ. Обучив систему на обучающей выборке, по содержанию и структуре заголовков мы можем предсказать браузер, версию и платформу (ОС). Некоторые версии браузеров а даже отдельные браузеры могут иметь одинаковую структуру заголовков. Поэтому нам нужно сверять предсказанное значение с группой допустимых значений, которые мы также определяем по обучающей выборке

## Требования

1. Система должна быть динамичной. Постоянно выходят новые версии браузеров и в связи с этим систему регулярно переобучаться по новой выборке.
2. Ошибка первого рода (когда мы принимаем нормального пользователя за бота) должна быть не более 5%
3. Ошибка второго рода H1 (когда мы принимаем бота за нормального пользователя) должна быть минимально возможной. 

В основном H1 возникает в следующей ситуации: боты используют один из существующих браузерных движков, например Gecko (Firefox). Для снятия подозрений они имитируют естественное распределение браузеров/версий и подставляют соответствующие useragent. Но они имитируют также и firefox, коим они и так являются. Таким образом, если по распределению у нас 10% firefox и мы умеем очень точно определять браузер по заголовкам, то H1 будет у нас более 10%. Ситуация еще хуже с браузером chrome которого 60%. Поэтому нам важно минимизировать группы и предугадывать не только браузер, но и версию и платформу.

## Текущее состояние дел

В качестве фич используются признаки наличия заголовков с определенным содержанием и их последовательность.
Игнорируется содержание следующих заголовков:

```
'User-Agent',
'Referer',
'Accept-Language',
'Host',
'X-Host',
'X-Forwarded-For',
'Forwarded-For' ,
'X-Network-Type',
'Cookie',
'X-Wap-Profile',
'X-Gateway',
'Ua-Cpu',
'Rvbd-Csh',
'Dris-Orig-Src',
'X-Proxy-Id',
'Rvbd-Ssh',
'X-Requested-With'
```

(но их участие в последовательностях учитывается)
Также игнорируются очень редкие и с уникальными именами, которые нужно исключать подсчитывая их частоту.

Наиболее быстрой и точной моделью для прогнозирования заголовков оказалась DecisionTree

Тренировочные выборки находятся в архиве headers.zip в папке с этим документом. Данные в файлах в csv формате со следующими колонками:

1. Время (timestamp)
2. Ip
3. Заголовки в json формате

## Задачи

1. Определить оптимальный объем тренировочной выборки (модель DecisionTree склонна к переобучению)
2. Реализовать скрипт, который будет периодически переобучать рабочую модель на свежих данных.
3. Описать требования к разработке рабочего модуля для антинакрутки на базе заголовков.


## Комментарии

1. Данных по хедерам ботов нет. Их можно добыть, но, на это уйдет немало времени. Проще всего вам имитировать ботов подставляя случайный юзерагент.
2. DecisionTree дал такие результаты (score) по следующим разрезам (слоям) на обучающей выборке:
* Слой 0 (browser_name,) - 0.79
* Слой 1 (browser_name, browser_version) - 0.69
* Слой 2 (browser_name, browser_version, platform) - 0.64
* Слой 3 (browser_name, browser_version, platform, platform_version) - 0.65
Это хорошие показатели, потому как многие версии браузеров и даже браузеры сильно походят друг на друга. Поэтому на обучающей выборке нужно еще динамически составлять карту соответствий, например "Firefox 53 может определяться как Firefox 52, Firefox 51 и Firefox 48" и т.п. 
3. В случае нахождения источника с сильными отклонениями аналитики будут перепроверять все переходы по разным другим параметрам.
